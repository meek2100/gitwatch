---
name: Gitwatch QA (Sequential Debug)

on:
  workflow_dispatch:
    inputs:
      branch:
        description: "The branch, tag, or SHA to checkout"
        required: true
        default: "master"
      test_files:
        description: "Space-separated list/glob of test files (e.g., 'commitcmd.bats' or '*.bats'). Runs inside the 'tests/' directory."
        required: false
        default: "*.bats" # Default runs all tests
      timeout_in_minutes:
        description: "Job timeout in minutes (default: 3, max: 2160)"
        required: true
        default: "3"

permissions: {}

jobs:
  #-------------------------------------------------------------------------
  bats:
    name: BATS Tests
    if: "!contains(github.event.head_commit.message, '#noaction')"
    permissions:
      contents: read
      actions: write
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macOS-latest]
    runs-on: ${{ matrix.os }}
    timeout-minutes: ${{ fromJSON(github.event.inputs.timeout_in_minutes) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v5
        with:
          persist-credentials: false
          ref: ${{ github.event.inputs.branch }}

      - name: Reusable Setup (Checkout, BATS, Version)
        uses: ./.github/actions/setup
        id: setup
        with:
          os: ${{ matrix.os }}
          setup-bats: true

      - name: Cache apt packages (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: ${{ runner.os }}-apt-${{ hashFiles('**/gitwatch.yaml') }}
          restore-keys: |
            ${{ runner.os }}-apt-

      - name: Cache brew packages (macOS)
        if: matrix.os == 'macOS-latest'
        uses: actions/cache@v4
        with:
          path: ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-brew-${{ hashFiles('**/gitwatch.yaml') }}
          restore-keys: |
            ${{ runner.os }}-brew-

      - name: Install gitwatch OS dependencies
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "Linux" ]; then
            sudo apt-get update
            sudo apt-get -y install inotify-tools util-linux parallel
          elif [ "$RUNNER_OS" == "macOS" ]; then
            # Install core Homebrew dependencies only.
            # Docker/Colima/QEMU is handled by the next action.
            brew install fswatch flock coreutils bash parallel
          else
            echo "Unsupported OS: $RUNNER_OS"
            exit 1
          fi

      - name: Setup Docker on macOS (External Action)
        if: matrix.os == 'macOS-latest'
        uses: douglascamata/setup-docker-macos-action@v1
        continue-on-error: true

      - name: Verify script content before test
        shell: bash
        run: |
          echo "--- Verifying gitwatch.sh content ---"
          grep -C 3 'if \[ "$staged_tree_hash" = "$head_tree_hash" \];' gitwatch.sh
          echo "--- Verifying debounce logic (PID File Method) ---"
          grep -C 3 'if \[ -f "$TIMER_PID_FILE" \];' gitwatch.sh
          echo "--- End of verification ---"

      - name: Archive gitwatch.sh script for debugging
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: gitwatch-script-debug-${{ matrix.os }}
          path: gitwatch.sh
          retention-days: 7

      - name: Run BATS tests (from UI input)
        id: bats_run
        shell: bash
        env:
          BATS_LIB_PATH: "${{ steps.setup.outputs.bats-lib-path }}:${{ github.workspace }}/tests"
          BATS_TAP_FILE: "${{ github.workspace }}/bats_results.tap"
        if: github.event.inputs.test_files != ''
        continue-on-error: true # <-- IMPORTANT
        run: |
          set -o pipefail

          # Configure git for tests that require it
          git config --global user.email "test@email.com"
          git config --global user.name "test user"

          # Set AND EXPORT the variable
          export TEST_FILES_TO_RUN="${{ github.event.inputs.test_files }}"
          echo "Test files glob: $TEST_FILES_TO_RUN"

          export BATS_LIB_PATH
          export BATS_TAP_FILE

          echo "Clearing old TAP file at ${BATS_TAP_FILE}"
          > "${BATS_TAP_FILE}"

          # Get the number of available processor cores
          NPROC=1
          if [ "$RUNNER_OS" == "Linux" ];
          then
            NPROC=$(nproc)
          elif [ "$RUNNER_OS" == "macOS" ];
          then
            NPROC=$(sysctl -n hw.ncpu)
          fi
          echo "Running BATS tests in parallel using $NPROC cores..."

          # --- MODIFICATION: Correctly find files from glob or list ---
          echo "Finding test files for glob/list: $TEST_FILES_TO_RUN"
          # Use xargs to run find for each space-separated item in the input
          # This correctly handles both "file1.bats file2.bats" and "*.bats"
          TEST_FILE_LIST=$(echo $TEST_FILES_TO_RUN | xargs -n 1 -I {} find ./tests -name {} | sort)

          if [ -z "$TEST_FILE_LIST" ]; then
              echo "No test files found matching: $TEST_FILES_TO_RUN"
              exit 0 # Exit gracefully
          fi
          echo "Running BATS on files: $TEST_FILE_LIST"
          # --- END MODIFICATION ---

          if [ "$RUNNER_OS" == "Linux" ];
          then
            echo "Running with kcov for code coverage..."
            mkdir -p ${{ github.workspace }}/coverage
            echo "Current directory for kcov: $(pwd)"

            kcov --include-path=./ --exclude-path=tests/ ${{ github.workspace }}/coverage/ \
              bats --jobs $NPROC --tap $TEST_FILE_LIST | tee "${BATS_TAP_FILE}"
          else
            echo "Running tests in parallel for clear debug logging..."
            bats --jobs $NPROC --tap $TEST_FILE_LIST | tee "${BATS_TAP_FILE}"
          fi

          # Capture the exit code. We check the TAP file for "not ok"
          # instead of PIPESTATUS[0] because the loop might have failures.
          BATS_EXIT_CODE=0
          if grep -q "^not ok" "${BATS_TAP_FILE}"; then
            echo "One or more tests failed."
            BATS_EXIT_CODE=1
          else
            echo "All tests passed."
          fi

          echo "BATS raw exit code: ${BATS_EXIT_CODE}"
          echo "bats_exit_code_internal=${BATS_EXIT_CODE}" >> $GITHUB_OUTPUT

          echo "===================================================================="
          echo "Finished running tests. Verifying ${BATS_TAP_FILE} content..."
          if [ -f "${BATS_TAP_FILE}" ]; then
            cat "${BATS_TAP_FILE}"
          else
            echo "ERROR: BATS_TAP_FILE not found at ${BATS_TAP_FILE}"
          fi
          echo "--- End of verification ---"
          echo "===================================================================="

          exit $BATS_EXIT_CODE

      - name: No Tests Specified
        if: github.event.inputs.test_files == ''
        run: |
          echo "No test files specified in 'test_files' input. Skipping BATS run."

      - name: Upload coverage report (Linux)
        if: matrix.os == 'ubuntu-latest' && github.event.inputs.test_files != ''
        uses: actions/upload-artifact@v5
        with:
          name: coverage-report-linux-debug
          path: coverage/
          retention-days: 7

      - name: Generate Test Summary
        if: always() && github.event.inputs.test_files != ''
        shell: bash
        env:
          BATS_TAP_FILE: "${{ github.workspace }}/bats_results.tap"
        run: |
          echo "--- Reading summary from ${BATS_TAP_FILE} ---"

          # Parse kcov JSON output
          if [ "${{ matrix.os }}" == "ubuntu-latest" ]; then
            echo "### ðŸ“ˆ Code Coverage (Linux)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Install jq to parse JSON
            sudo apt-get install -y jq > /dev/null 2>&1

            COVERAGE_FILE="${{ github.workspace }}/coverage/bats/coverage.json"

            if [ -f "$COVERAGE_FILE" ]; then
              echo "Found coverage file at $COVERAGE_FILE"

              # Extract data. Use '|| echo "0"' as a fallback.
              PERCENT=$(jq -r '.percent_covered' "$COVERAGE_FILE" || echo "0")
              EXECUTED=$(jq -r '.covered_lines' "$COVERAGE_FILE" || echo "0")
              TOTAL=$(jq -r '.total_lines' "$COVERAGE_FILE" || echo "0")

              # Format the output
              echo "**${PERCENT}%** covered" >> $GITHUB_STEP_SUMMARY
              echo "(${EXECUTED} / ${TOTAL} instrumented lines)" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Full report uploaded as **coverage-report-linux-debug**." >> $GITHUB_STEP_SUMMARY
            else
              echo "Kcov coverage.json file not found at $COVERAGE_FILE." >> $GITHUB_STEP_SUMMARY
              echo "Kcov report uploaded as **coverage-report-linux-debug**." >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
          fi

          if [ ! -f "${BATS_TAP_FILE}" ]; then
            echo "BATS results file (${BATS_TAP_FILE}) not found." >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          AWK_SCRIPT=$(cat << 'EOF'
          BEGIN {
              print "### BATS Test Results"
              print ""
              print "| Test | File | Status |"
              print "| --- | --- | --- |"
              passed = 0
              failed = 0
              skipped = 0
              planned_tests = 0
              current_file = "N/A"
          }

          # Capture the total planned tests
          /^1\.\.[0-9]+/ {
            split($0, a, "..")
            planned_tests += a[2] # Sum all planned tests
            next
          }

          /^# file: / {
            current_file = $3
            sub(/.*\//, "", current_file)
            next
          }

          # Use POSIX-compatible regex match and field splitting
          /^(ok|not ok) [0-9]+ / {
            status_word = $1
            test_number = 0
            test_name_full = ""

            if (status_word == "not") {
                # Line is "not ok 1 test_name..."
                status_word = "not ok"
                test_number = $3
                # Rebuild full name from $4 onwards
                test_name_full = $4
                for (i = 5; i <= NF; i++) {
                  test_name_full = test_name_full " " $i
                }
            } else {
                # Line is "ok 2 test_name..."
                status_word = "ok"
                test_number = $2
                # Rebuild full name from $3 onwards
                test_name_full = $3
                for (i = 4; i <= NF; i++) {
                  test_name_full = test_name_full " " $i
                }
            }

            file_name = current_file
            status = ""
            icon = ""

            # Check for # skip
            skip_pos = index(test_name_full, "# skip")
            if (skip_pos == 0) {
              skip_pos = index(test_name_full, "# SKIP")
            }

            if (status_word == "ok" && skip_pos > 0) {
                # --- IS SKIPPED ---
                skipped++
                status = "Skipped"
                icon = "ðŸŸ¡"
                # Get the test name *before* the skip directive
                test_name_full = substr(test_name_full, 1, skip_pos - 1)
            } else {
                # --- IS PASS/FAIL ---
                if (status_word == "ok") {
                    status = "Passed"
                    icon = "âœ…"
                    passed++
                } else {
                    status = "Failed"
                    icon = "âŒ"
                    failed++
                }
            }

            # Clean up the full test name (which might have trailing spaces if it was a skip)
            gsub(/^ */, "", test_name_full)
            gsub(/ *$/, "", test_name_full)

            gsub(/\|/, "\\|", file_name)
            gsub(/\|/, "\\|", test_name_full)

            print "| " test_number " " test_name_full " | " file_name " | " icon " " status " |"
          }

          # Calculate and print the final summary
          END {
            # Removed 'not_run' logic
            print ""
            print "---"
            print "**Summary:** " passed " passed, " failed " failed, " skipped " skipped."
          }
          EOF
          )

          AWK_OUTPUT=$(awk "$AWK_SCRIPT" "${BATS_TAP_FILE}")

          echo "$AWK_OUTPUT" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Debug: BATS_EXIT_CODE from previous step was: '${{ steps.bats_run.outputs.bats_exit_code_internal }}'"

          if [ "${{ steps.bats_run.outputs.bats_exit_code_internal }}" != "0" ]; then
            echo ":red_circle: **Overall Status: Tests Failed**" >> $GITHUB_STEP_SUMMARY
            exit 1 # Fail this summary step
          else
            echo ":white_check_mark: **Overall Status: All Tests Passed**" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload BATS TAP Artifact
        uses: actions/upload-artifact@v5
        if: always() && github.event.inputs.test_files != ''
        with:
          name: bats-results-tap-${{ matrix.os }}
          path: ${{ github.workspace }}/bats_results.tap
          retention-days: 7
