---
name: Gitwatch QA (Sequential Debug)

on:
  workflow_dispatch:
    inputs:
      branch:
        description: "The branch, tag, or SHA to checkout"
        required: true
        default: "master"
      test_files:
        description: "Space-separated list/glob of test files (e.g., 'commitcmd.bats' or '*.bats'). Runs inside the 'tests/' directory."
        required: false
        default: "" # Default to running no tests
      timeout_in_minutes:
        description: "Job timeout in minutes (default: 3, max: 2160)"
        required: true
        default: "3"

permissions: {}

jobs:
  #-------------------------------------------------------------------------
  bats:
    name: BATS Tests
    if: "!contains(github.event.head_commit.message, '#noaction')"
    permissions:
      contents: read
      # Allow writing artifacts
      actions: write
    strategy:
      # Fail-fast is false so you can see failures on both OSs
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macOS-latest]
    runs-on: ${{ matrix.os }}
    # --- MODIFIED TIMEOUT ---
    # Use the input from the workflow_dispatch form
    # We use fromJSON to convert the input string (e.g., '3') to a number
    timeout-minutes: ${{ fromJSON(github.event.inputs.timeout_in_minutes) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          persist-credentials: false
          ref: ${{ github.event.inputs.branch }} # <-- USES BRANCH INPUT

      - name: Reusable Setup (Checkout, BATS, Version)
        uses: ./.github/actions/setup
        id: setup
        with:
          os: ${{ matrix.os }}
          setup-bats: true

      - name: Cache apt packages (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: ${{ runner.os }}-apt-${{ hashFiles('**/gitwatch.yaml') }}
          restore-keys: |
            ${{ runner.os }}-apt-

      - name: Cache brew packages (macOS)
        if: matrix.os == 'macOS-latest'
        uses: actions/cache@v4
        with:
          path: ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-brew-${{ hashFiles('**/gitwatch.yaml') }}
          restore-keys: |
            ${{ runner.os }}-brew-

      - name: Install gitwatch OS dependencies
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "Linux" ]; then
            sudo apt-get update
            sudo apt-get -y install inotify-tools util-linux
          elif [ "$RUNNER_OS" == "macOS" ]; then
            brew install fswatch flock coreutils bash
          else
            echo "Unsupported OS: $RUNNER_OS"
            exit 1
          fi

      - name: Display gitwatch.sh content before testing
        shell: bash
        run: |
          echo "--- Displaying gitwatch.sh from $(pwd) ---"
          cat gitwatch.sh
          echo "--- End of gitwatch.sh ---"

      - name: Verify script content before test
        shell: bash
        run: |
          echo "--- Verifying gitwatch.sh content ---"
          # Verify the git write-tree check
          grep -C 3 'if \[ "$staged_tree_hash" = "$head_tree_hash" \];' gitwatch.sh
          echo "--- Verifying debounce logic (PID File Method) ---"
          # Verify the start of the new debounce logic block using the PID file
          grep -C 3 'if \[ -f "$TIMER_PID_FILE" \];' gitwatch.sh
          echo "--- End of verification ---"

      - name: Run BATS tests (from UI input)
        id: bats_run
        shell: bash
        env:
          BATS_LIB_PATH: "${{ steps.setup.outputs.bats-lib-path }}:${{ github.workspace }}/tests"
        if: github.event.inputs.test_files != ''
        continue-on-error: true
        run: |
          git config --global user.email "test@email.com"
          git config --global user.name "test user"

          # Ensure we are in the tests directory to run bats and save the results
          cd tests
          echo "Current directory for BATS tests: $(pwd)"

          echo "===================================================================="
          echo "Running BATS tests (from 'tests/' directory) from workflow_dispatch input:"
          echo "${{ github.event.inputs.test_files }}"
          echo "===================================================================="

          # Run bats and tee the output to bats_results.tap
          # The file will be created in the `tests/` directory
          bats --tap ${{ github.event.inputs.test_files }} | tee bats_results.tap

          echo "===================================================================="
          echo "Finished running tests."
          echo "===================================================================="
          # Also, ensure we capture the exit code of bats for later use if continue-on-error is true
          # Note: continue-on-error true means steps.bats_run.outcome will still be "success"
          # if a script fails. We'll rely on parsing the TAP file for actual test results.

      - name: No Tests Specified
        if: github.event.inputs.test_files == ''
        run: |
          echo "No test files specified in 'test_files' input. Skipping BATS run."

      # --- MODIFIED STEP TO GENERATE SUMMARY ---
      - name: Generate Test Summary
        if: always() && github.event.inputs.test_files != '' # Only run if tests were actually attempted
        shell: bash
        run: |
          # Navigate to the 'tests' directory where bats_results.tap should be
          cd tests
          echo "Current directory for summary generation: $(pwd)"

          # --- DEBUGGING: List files and cat the TAP file ---
          echo "--- Contents of current directory (tests/) ---"
          ls -l
          echo "--- End of directory listing ---"

          echo "--- Content of bats_results.tap (if exists) ---"
          if [ -f bats_results.tap ]; then
            cat bats_results.tap
          else
            echo "bats_results.tap NOT FOUND."
            echo "No BATS test results to summarize. Ensure tests ran and generated output." >> $GITHUB_STEP_SUMMARY
            exit 0 # Exit cleanly if no results file to avoid awk errors
          fi
          echo "--- End of bats_results.tap content ---"

          # Use awk to parse the TAP output and generate GitHub-flavored Markdown
          # We'll also capture if any 'not ok' lines were found to set the overall status
          AWK_SCRIPT=$(cat << 'EOF'
          BEGIN {
            print "### BATS Test Results"
            print ""
            print "| Test | Status |"
            print "| --- | --- |"
            passed = 0
            failed = 0
            overall_failed = "false" # Flag to track if any test failed
          }
          # Match lines like "ok 1 - Test Name" or "not ok 2 - Test Name"
          /^(ok|not ok) [0-9]+ - / {
            name_start = index($0, "- ") + 2
            test_name = substr($0, name_start)
            gsub(/\|/, "\\|", test_name) # Sanitize for markdown table

            if ($1 == "ok") {
              print "| ✅ " test_name " | Passed |"
              passed++
            } else {
              print "| ❌ " test_name " | Failed |"
              failed++
              overall_failed = "true"
            }
          }
          END {
            print ""
            print "---"
            print "**Summary:** " passed " passed, " failed " failed."
            # Output a special line that we can grep for in the shell to determine overall status
            print "::set-output name=overall_failed::" overall_failed
          }
          EOF
          )

          # Execute awk and capture its output, including the custom output for overall_failed
          AWK_OUTPUT=$(echo -e "$(cat bats_results.tap)" | awk "$AWK_SCRIPT")
          echo "$AWK_OUTPUT" >> $GITHUB_STEP_SUMMARY

          # Extract the overall_failed status from the awk output
          OVERALL_FAILED_FLAG=$(echo "$AWK_OUTPUT" | grep "^::set-output name=overall_failed::" | cut -d':' -f4)

          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$OVERALL_FAILED_FLAG" == "true" ]; then
            echo ":red_circle: **Overall Status: Tests Failed**" >> $GITHUB_STEP_SUMMARY
          else
            echo ":white_check_mark: **Overall Status: All Tests Passed**" >> $GITHUB_STEP_SUMMARY
          fi

          # If any tests failed according to our awk script, fail this step to make the job red
          if [ "$OVERALL_FAILED_FLAG" == "true" ]; then
              exit 1
          fi
