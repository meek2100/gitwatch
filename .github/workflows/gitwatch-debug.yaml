---
name: Gitwatch QA (Sequential Debug)

on:
  workflow_dispatch:
    inputs:
      branch:
        description: "The branch, tag, or SHA to checkout"
        required: true
        default: "master"
      test_files:
        description: "Space-separated list/glob of test files (e.g., 'commitcmd.bats' or '*.bats'). Runs inside the 'tests/' directory."
        required: false
        default: "*.bats" # Default runs all tests
      timeout_in_minutes:
        description: "Job timeout in minutes (default: 3, max: 2160)"
        required: true
        default: "3"

permissions: {}

jobs:
  #-------------------------------------------------------------------------
  bats:
    name: BATS Tests
    if: "!contains(github.event.head_commit.message, '#noaction')"
    permissions:
      contents: read
      actions: write
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macOS-latest]
    runs-on: ${{ matrix.os }}
    timeout-minutes: ${{ fromJSON(github.event.inputs.timeout_in_minutes) }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          persist-credentials: false
          ref: ${{ github.event.inputs.branch }}

      - name: Reusable Setup (Checkout, BATS, Version)
        uses: ./.github/actions/setup
        id: setup
        with:
          os: ${{ matrix.os }}
          setup-bats: true

      - name: Cache apt packages (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: ${{ runner.os }}-apt-${{ hashFiles('**/gitwatch.yaml') }}
          restore-keys: |
            ${{ runner.os }}-apt-

      - name: Cache brew packages (macOS)
        if: matrix.os == 'macOS-latest'
        uses: actions/cache@v4
        with:
          path: ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-brew-${{ hashFiles('**/gitwatch.yaml') }}
          restore-keys: |
            ${{ runner.os }}-brew-

      - name: Install gitwatch OS dependencies
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "Linux" ]; then
            sudo apt-get update
            sudo apt-get -y install inotify-tools util-linux
          elif [ "$RUNNER_OS" == "macOS" ]; then
            brew install fswatch flock coreutils bash
          else
            echo "Unsupported OS: $RUNNER_OS"
            exit 1
          fi

      - name: Display gitwatch.sh content before testing
        shell: bash
        run: |
          echo "--- Displaying gitwatch.sh from $(pwd) ---"
          cat gitwatch.sh
          echo "--- End of gitwatch.sh ---"

      - name: Verify script content before test
        shell: bash
        run: |
          echo "--- Verifying gitwatch.sh content ---"
          grep -C 3 'if \[ "$staged_tree_hash" = "$head_tree_hash" \];' gitwatch.sh
          echo "--- Verifying debounce logic (PID File Method) ---"
          grep -C 3 'if \[ -f "$TIMER_PID_FILE" \];' gitwatch.sh
          echo "--- End of verification ---"

      # --- MODIFIED STEP: Loops through files to get names ---
      - name: Run BATS tests (from UI input)
        id: bats_run
        shell: bash
        env:
          BATS_LIB_PATH: "${{ steps.setup.outputs.bats-lib-path }}:${{ github.workspace }}/tests"
          BATS_TAP_FILE: "${{ github.workspace }}/bats_results.tap"
        if: github.event.inputs.test_files != ''
        continue-on-error: true # <-- IMPORTANT
        run: |
          set -o pipefail

          cd tests
          echo "Current directory for BATS tests: $(pwd)"
          echo "Running BATS tests sequentially and writing to ${BATS_TAP_FILE}"

          # Clear the log file
          > "${BATS_TAP_FILE}"

          OVERALL_EXIT_CODE=0

          # Loop through each file provided by the input glob
          for file in ${{ github.event.inputs.test_files }}; do
            echo "--- Running test file: $file ---"

            # Run bats on the single file, pipe to awk, and append to the main log
            # This awk script prepends the filename to the test lines
            bats --tap "$file" | awk -v filename="$file" '
              /^(ok|not ok) [0-9]+ / {
                # Prepend the filename and a custom delimiter
                print filename " | " $0
              }
              # Pass through other lines (like 1..N)
              !/^(ok|not ok) [0-9]+ / {
                print
              }
            ' >> "${BATS_TAP_FILE}"

            # Capture the exit code of 'bats' (the first command in the pipe)
            BATS_SINGLE_EXIT_CODE=${PIPESTATUS[0]}
            echo "Exit code for $file: $BATS_SINGLE_EXIT_CODE"

            # If this run failed, update the overall exit code
            if [ "$BATS_SINGLE_EXIT_CODE" -ne 0 ]; then
              OVERALL_EXIT_CODE=1
            fi
          done

          echo "BATS raw exit code (overall): ${OVERALL_EXIT_CODE}"
          echo "bats_exit_code_internal=${OVERALL_EXIT_CODE}" >> $GITHUB_OUTPUT

          echo "===================================================================="
          echo "Finished running tests. Verifying ${BATS_TAP_FILE} content..."
          cat "${BATS_TAP_FILE}"
          echo "--- End of verification ---"
          echo "===================================================================="

          exit $OVERALL_EXIT_CODE

      - name: No Tests Specified
        if: github.event.inputs.test_files == ''
        run: |
          echo "No test files specified in 'test_files' input. Skipping BATS run."

      # --- MODIFIED STEP: New 'awk' script for parsing "File | TAP Line" ---
      - name: Generate Test Summary
        if: always() && github.event.inputs.test_files != ''
        shell: bash
        env:
          BATS_TAP_FILE: "${{ github.workspace }}/bats_results.tap"
        run: |
          echo "--- Reading summary from ${BATS_TAP_FILE} ---"

          if [ ! -f "${BATS_TAP_FILE}" ]; then
            echo "BATS results file (${BATS_TAP_FILE}) not found." >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # This 'awk' script now splits the line at " | "
          AWK_SCRIPT=$(cat << 'EOF'
          BEGIN {
            # Set the Field Separator to be " | "
            FS = " \\| "

            print "### BATS Test Results"
            print ""
            print "| File | Test | Status |"
            print "| --- | --- | --- |"
            passed = 0
            failed = 0
          }

          # Check if we have our 2 fields
          NF == 2 {
            file_name = $1
            tap_line = $2

            status_word = "unknown"
            test_name = "N/A"

            # Check if line starts with "ok" or "not ok"
            if (index(tap_line, "ok ") == 1) {
                status_word = "ok"
                # Find the test number (field 2)
                space1_pos = index(tap_line, " ")
                space2_pos = index(tap_line, " ", space1_pos + 1)
                name_start = space2_pos + 1
                test_name = substr(tap_line, name_start)

            } else if (index(tap_line, "not ok ") == 1) {
                status_word = "not ok"
                # Find the test number (field 3)
                space1_pos = index(tap_line, " ") # after "not"
                space2_pos = index(tap_line, " ", space1_pos + 1) # after "ok"
                space3_pos = index(tap_line, " ", space2_pos + 1) # after number
                name_start = space3_pos + 1
                test_name = substr(tap_line, name_start)
            }

            # Sanitize for markdown table
            gsub(/\|/, "\\|", file_name)
            gsub(/\|/, "\\|", test_name)

            if (status_word == "ok") {
              print "| " file_name " | ✅ " test_name " | Passed |"
              passed++
            } else if (status_word == "not ok") {
              print "| " file_name " | ❌ " test_name " | Failed |"
              failed++
            }
          }

          END {
            print ""
            print "---"
            print "**Summary:** " passed " passed, " failed " failed."
          }
          EOF
          )

          AWK_OUTPUT=$(awk "$AWK_SCRIPT" "${BATS_TAP_FILE}")

          echo "$AWK_OUTPUT" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Debug: BATS_EXIT_CODE from previous step was: '${{ steps.bats_run.outputs.bats_exit_code_internal }}'"

          if [ "${{ steps.bats_run.outputs.bats_exit_code_internal }}" != "0" ]; then
            echo ":red_circle: **Overall Status: Tests Failed**" >> $GITHUB_STEP_SUMMARY
            exit 1 # Fail this summary step
          else
            echo ":white_check_mark: **Overall Status: All Tests Passed**" >> $GITHUB_STEP_SUMMARY
          fi
