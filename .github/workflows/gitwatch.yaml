---
name: Gitwatch QA

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

permissions: {}

jobs:
  #-------------------------------------------------------------------------
  bats:
    name: BATS Tests
    if: "!contains(github.event.head_commit.message, '#noaction')"
    permissions:
      contents: read
      # Allow writing artifacts
      actions: write
    strategy:
      # Fail-fast is false so you can see failures on both OSs
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macOS-latest]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 10

    steps:
      - name: Checkout Repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          persist-credentials: false

      - name: Reusable Setup (Checkout, BATS, Version)
        uses: ./.github/actions/setup
        id: setup
        with:
          os: ${{ matrix.os }}
          setup-bats: true

      - name: Cache apt packages (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/cache@v4
        with:
          path: /var/cache/apt
          key: ${{ runner.os }}-apt-${{ hashFiles('**/gitwatch.yaml') }}
          restore-keys: |
            ${{ runner.os }}-apt-

      - name: Cache brew packages (macOS)
        if: matrix.os == 'macOS-latest'
        uses: actions/cache@v4
        with:
          path: ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-brew-${{ hashFiles('**/gitwatch.yaml') }}
          restore-keys: |
            ${{ runner.os }}-brew-

      - name: Install gitwatch OS dependencies
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "Linux" ]; then
            sudo apt-get update
            sudo apt-get -y install inotify-tools util-linux
          elif [ "$RUNNER_OS" == "macOS" ];
          then
            brew install fswatch flock coreutils bash
          else
            echo "Unsupported OS: $RUNNER_OS"
            exit 1
          fi

      - name: Verify script content before test
        shell: bash
        run: |
          echo "--- Verifying gitwatch.sh content ---"
          # Verify the git write-tree check
          # 'gitwatch.sh' is now on the same line as grep
          grep -C 3 'if \[ "$staged_tree_hash" = "$head_tree_hash" \];' gitwatch.sh
          echo "--- Verifying debounce logic (PID File Method) ---"
          # Verify the start of the new debounce logic block using the PID file
          # 'gitwatch.sh' is now on the same line as grep
          grep -C 3 'if \[ -f "$TIMER_PID_FILE" \];' gitwatch.sh
          echo "--- End of verification ---"

      # --- NEW STEP: Archives the script instead of printing it ---
      - name: Archive gitwatch.sh script for debugging
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: gitwatch-script-${{ matrix.os }}
          path: gitwatch.sh
          retention-days: 7

      - name: Run tests (and coverage on Linux)
        id: bats_run
        continue-on-error: true
        shell: bash
        env:
          BATS_LIB_PATH: "${{ steps.setup.outputs.bats-lib-path }}:${{ github.workspace }}/tests"
          BATS_TAP_FILE: "${{ github.workspace }}/bats_results.tap"
        run: |
          set -o pipefail

          git config --global user.email "test@email.com"
          git config --global user.name "test user"

          cd tests

          # Get the number of available processor cores
          NPROC=1
          if [ "$RUNNER_OS" == "Linux" ];
          then
            NPROC=$(nproc)
          elif [ "$RUNNER_OS" == "macOS" ];
          then
            NPROC=$(sysctl -n hw.ncpu)
          fi

          echo "Running BATS tests in parallel using $NPROC cores..."

          if [ "$RUNNER_OS" == "Linux" ];
          then
            # Run with kcov on Linux
            echo "Running with kcov for code coverage..."
            mkdir -p ../coverage
            cd ..

            # kcov runs bats, which outputs TAP, which is tee'd to the file
            # We add --jobs "$NPROC" here for parallel kcov
            kcov --include-path=./ --bash-parser=./gitwatch.sh coverage/ bats --jobs "$NPROC" --tap $(find tests -name "*.bats") | tee "${BATS_TAP_FILE}"
          else
            # Use 'bats --jobs' for parallel execution
            bats --jobs "$NPROC" --tap $(find . -name "*.bats") | tee "${BATS_TAP_FILE}"
          fi

          # Capture the exit code of 'bats' (or 'kcov')
          BATS_EXIT_CODE=${PIPESTATUS[0]}
          echo "BATS raw exit code: ${BATS_EXIT_CODE}"
          echo "bats_exit_code_internal=${BATS_EXIT_CODE}" >> $GITHUB_OUTPUT

          echo "===================================================================="
          echo "Finished running tests. Verifying ${BATS_TAP_FILE} content..."
          if [ -f "${BATS_TAP_FILE}" ]; then
            cat "${BATS_TAP_FILE}"
          else
            echo "ERROR: BATS_TAP_FILE not found at ${BATS_TAP_FILE}"
          fi
          echo "--- End of verification ---"
          echo "===================================================================="

          exit $BATS_EXIT_CODE

      - name: Upload coverage report (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-linux
          path: coverage/
          retention-days: 7

      - name: Generate Test Summary
        if: always() # This step will always run
        shell: bash
        env:
          BATS_TAP_FILE: "${{ github.workspace }}/bats_results.tap"
        run: |
          echo "--- Reading summary from ${BATS_TAP_FILE} ---"

          if [ ! -f "${BATS_TAP_FILE}" ]; then
            echo "BATS results file (${BATS_TAP_FILE}) not found." >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # This 'awk' script now splits the full test name into "Test Name" and "Result"
          AWK_SCRIPT=$(cat << 'EOF'
          BEGIN {
            print "### BATS Test Results"
            print ""
            # New 4-column header
            print "| File | Test | Result | Status |"
            print "| --- | --- | --- | --- |"
            passed = 0
            failed = 0
            current_file = "N/A" # Holds the filename
          }

          # Capture the filename (thanks to our helper script fix)
          /^# file: / {
            current_file = $3
            # Strip the 'tests/' prefix for a cleaner name
            sub(/^tests\//, "", current_file)
            next
          }

          # Match test result lines
          /^(ok|not ok) [0-9]+ / {
            status_word = $1
            test_number = $2

            # Find the start of the full test name
            name_start = index($0, test_number " ") + length(test_number) + 1
            test_name_full = substr($0, name_start)

            # --- New 4-column logic ---
            file_name = current_file
            test_name = ""
            test_result = ""
            status = ""
            icon = ""

            # Split the full name into test_name and test_result
            split_pos = index(test_name_full, ": ")
            if (split_pos > 0) {
                test_name = substr(test_name_full, 1, split_pos - 1)
                test_result = substr(test_name_full, split_pos + 2)
            } else {
                test_name = test_name_full # Use the whole string as the "name"
                test_result = "(No result text)" # No separate result
            }

            if (status_word == "ok") {
                status = "Passed"
                icon = "✅"
                passed++
            } else {
                status = "Failed"
                icon = "❌"
                failed++
            }

            # Sanitize all fields for markdown
            gsub(/\|/, "\\|", file_name)
            gsub(/\|/, "\\|", test_name)
            gsub(/\|/, "\\|", test_result)

            # Print the new 4-column format
            print "| " file_name " | " test_name " | " icon " " test_result " | " status " |"
            # --- End new logic ---
          }

          END {
            print ""
            print "---"
            print "**Summary:** " passed " passed, " failed " failed."
          }
          EOF
          )

          AWK_OUTPUT=$(awk "$AWK_SCRIPT" "${BATS_TAP_FILE}")

          echo "$AWK_OUTPUT" >> $GITHUB_STEP_SUMMARY

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Debug: BATS_EXIT_CODE from previous step was: '${{ steps.bats_run.outputs.bats_exit_code_internal }}'"

          if [ "${{ steps.bats_run.outputs.bats_exit_code_internal }}" != "0" ]; then
            echo ":red_circle: **Overall Status: Tests Failed**" >> $GITHUB_STEP_SUMMARY
            exit 1 # Fail this summary step
          else
            echo ":white_check_mark: **Overall Status: All Tests Passed**" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload BATS TAP Artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: bats-results-tap-${{ matrix.os }}
          path: ${{ github.workspace }}/bats_results.tap
          retention-days: 7
